;;;; git integration for hyperfine(1):
;;;; https://github.com/sharkdp/hyperfine
;;;;;
;;;; Currently requires patches of mine to the command:
;;;; https://github.com/sharkdp/hyperfine/pull/447 &
;;;; https://github.com/sharkdp/hyperfine/pull/448


;;; Worktree management for hyperfine
;;;
;;; To test a given git revision I setup a worktree for the current git
;;; directory in "$XDG_RUNTIME_DIR/git-perf-{r}", which will be e.g.:
;;;
;;;     /run/user/1001/git-perf-HEAD
;;;     /run/user/1001/git-perf-HEAD~
;;;

[alias]
;; wt-path: echo {r} worktree path
wt-path = "!f() { \
	echo \"$XDG_RUNTIME_DIR/git-perf-$1\"; \
}; f"
;; wt-add-rev: setup a new worktree
wt-add-rev = "!f() { \
	unset GIT_DIR; \
	export GIT_DIR; \
	git worktree add \"$(git wt-path $1)\" \"$1\" 2>/dev/null || :&& \
	~/g/git.meta/config.mak.sh -C \"$(git wt-path $1)\"; \
}; f"
;; wt-reset-rev: set a worktree to a <rev> {r} in *my* repo, not theirs
wt-reset-rev = "!f() { \
	unset GIT_DIR; \
	export GIT_DIR; \
	ref=\"$1\" && \
	shift; \
	rev=\"$(git rev-parse \"$ref\")\" && \
	path=\"$(git wt-path \"$ref\")\" && \
	echo \"$(tput bold; tput setaf 1)checking out <$rev> in <$path>$(tput sgr0)\" && \
	git -C \"$path\" reset --hard \"$rev\"; \
}; f"
;; wt-assert-rev: sanity check that I'm on the {r} I'd like. I once
;; had a heisenbug that came down to a stupid issue with a missing
;; "cd" below...
wt-assert-rev = "!f() { \
	unset GIT_DIR; \
	export GIT_DIR; \
	ref=\"$1\" && \
	shift; \
	path=\"$(git wt-path \"$ref\")\" && \
	expect=\"$(git rev-parse \"$ref\")\" && \
	actual=\"$(git -C \"$path\" rev-parse HEAD)\" && \
	if test \"$expect\" != \"$actual\"; \
	then \
		echo \"$(tput bold; tput setaf 1)expected $actual in $path to be $expect$(tput sgr0)\"; \
		exit 1; \
	fi; \
}; f"
;;;; test: git wt-make HEAD all test V='"foo bar"'
wt-make = "!f() { \
	unset GIT_DIR; \
	export GIT_DIR; \
	ref=\"$1\" && \
	path=\"$(git wt-path \"$ref\")\" && \
	rev=\"$(git -C \"$path\" rev-parse HEAD)\" && \
	shift && \
	make -j \"$(nproc)\" -C \"$path\" \"$@\"; \
 }; f"

;; hf-cmp: The real workhorse here and hyperfine(1) command
;; runner. Takes:
;;
;;    $1 = build command, can be a string like "make && other-cmd"
;;    $2 = test command, can likewise be chained
;;    $@ = Any other arguments to hyperfine(1)
;;
;; Synopsis:
;;    git hf-cmp 'make' 'make test' -L r HEAD,HEAD~ -r 1 --show-output
;;
;; Debug or inspect what this would run by prefixing "hyperfine" with:
;;
;;     printf \"arg: %s\\n\"
hf-cmp = "!f() { \
	unset GIT_DIR; \
	export GIT_DIR; \
	a=$1; \
	b=$2; \
	shift 2; \
	hyperfine \
	-b \"git wt-add-rev {r} && \
	     git wt-reset-rev {r} && \
	     git wt-assert-rev {r} && \
	     cd \\\"$(git wt-path {r})\\\" && \
	     $a \
	\" \
	--command-name=\"$(tput setaf 6)$b$(tput sgr0)' in '$(tput setaf 6)git reference {r}$(tput sgr0)\"  \
	\"(cd \\\"\\$(git wt-path {r})\\\" && $b)\" \
	\"$@\"; \
}; f"

;; hf-cmp-prev: alias for "hf-cmp" where -L r HEAD,HEAD~ is provided
;; for you
hf-cmp-prev = "!f() { \
	unset GIT_DIR; \
	export GIT_DIR; \
	a=$1; \
	b=$2; \
	shift 2; \
	git hf-cmp \"$a\" \"$b\" \
	-L r HEAD~,HEAD \
	\"$@\"; \
}; f"

;; hf-cmp-prev-make-all-all-warmup: test "make all" with warmup. For
;; testing the dry-run behavior of the Makefile
hf-cmp-prev-make-all-all-warmup = "!f() { \
	git hf-cmp-prev \
	\"git wt-make {r} all\" \
	\"git wt-make {r} all\" \
	--warmup=1; \
}; f"

